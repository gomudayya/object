# 4장 설계품질과 트레이드 오프

### 좋은 글귀들

- 코드 중복은 악의 근원이다.

---

## 상태 중심(데이터 중심)설계 vs 책임 중심 설계

- 상태는 구현에 속한다.
- 구현은 불안정하다. 변하기 쉬운 요소이다.
- 책임은 인터페이스이다.
- 인터페이스는 구현에 비해 안정적이다.

---

## 캡슐화, 응집도, 결합도

- 캡슐화
  - 외부에서 알 필요가 없는 부분을 감춘다. 
  - 즉, 불안정한 구현에 대한 내용을 인터페이스 뒤로 숨긴다.
  - 이렇게 함으로써 변경의 여파를 통제할 수 있다. (변경에 대한 파장이 퍼져나가지 않음)

- 응집도
  - 모듈 내부 요소들이 연관되어 있는 정도
  - 모듈 내부에서 긴밀하게 협력한다면 높은 응집도를 갖는다.
- 결합도
  - 의존성의 정도
  - 어떤 모듈이 다른 모듈에 대해 너무 자세히 알고있다면 높은 결합도를 갖는다.



**응집도와 결합도는 변경의 관점에서 바라보아야 한다.**
   
응집도가 낮다면, 변경이 발생했을 때 코드구석구석을 헤매게 되고, 여러 모듈을 수정해야한다.
   
결합도도 마찬가지이다. 결합도가 높으면 변경의 여파가 여러 모듈에 미치게 된다.

---

## 예제의 데이터 중심의 코드의 문제점

- 캡슐화 위반
  - 접근자(getter)와 수정자(setter)의 남용은 온전하게 구현을 숨기지 못한다.
- 높은 결합도
  - 여러 데이터 객체를 사용하는 제어로직이 있는 객체는 다수의 객체에 강하게 결합된다.(ReservationAgency)
  - 시스템의 어떤 변경도 ReservationAgency의 변경을 유발한다.
- 낮은 응집도
  - 예시 : 새로운 할인정책 추가
  - MovieType, ReservationAgency, Movie << 3곳을 변경해야함


### 리팩토링을 해도 Chapter4의 코드가 부족한이유

내부 구현을 숨기고, 데이터와 동작을 캡슐화하고, 객체가 자율성을 가지도록 리팩토링을 해도 여전히 부족하다

**[ 부족한 이유 ]**

- 메서드의 시그니처로 구현을 노출한다. (인터페이스가 구현정보를 노출시킴)
  - isDiscountable() 은 메서드의 파라미터에서
  - calculate~~~DiscountFee()는 메서드의 이름에서 내부구현을 노출시킨다.
- 여전히 코드변경시 여러모듈을 같이 변경해야 한다.

**왜 이럴까?**

-> 처음부터 데이터 중심 설계를 했기 때문에

### 데이터 중심 설계의 문제점

- 본질적으로 너무 이른시기에 데이터에 관해 결정하도록 강요한다.
  - 데이터도 구현의 일부이다.
  - 따라서 데이터 중심 설계는 설계의 시작부터 내부 구현에 초점을 맞추게 된다.
- 협력이라는 문맥을 고려하지 않고, 객체를 고립시킨 채 오퍼레이션(동작)을 결정한다.
  - 객체지향 설계의 초점은 객체의 내부가 아닌 외부(협력)을 바라보아야 한다.