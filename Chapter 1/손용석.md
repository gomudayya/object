``# 정리

요구사항에 맞춰서 개발을 하여 동작을 하도록 만드는 것은 쉬운 일이다.

Bag, Audience, TicketOffice, TicketSeller, Theater 로 시작하는 코드는 각 역할에 맞춰 잘 동작하는 듯이 보여진다. 

요구사항에 단순히 맞추어 개발을 하게 되면, 다음과 같은 문제가 발생이 될 수 있다.

1. 변경 용이성의 이슈
2. 사람과의 의사 소통에 관련된 문제점 야기

코드들의 의존관계를 고려치 않고 개발을 하게 될 시에는 변경을 한번 하게 되면 다른 소스코드까지 일괄적으로 변경하게 될 가능성이 높아진다.

OOP에서는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이 목표이다.

## 캡슐화

목적 : 변경하기 쉬운 객체를 생성하는 것.

캡슐화를 통해 객체 내부로의 접근을 제한하면, 객체와 객체 사이의 결합도를 낮출 수 있음.

- 이를 통하여, 설계를 좀 더 쉽게 변곃알 수 있게 된다.

## 책임의 이동

- 각 객체는 자신을 스스로 책임 진다
  - 객체지향의 진실과 오해
    - 왕이 토끼에게 `진술`에 대한 요청을 하지만, `어떻게`할 것인가에 대해서는 논하지 않는다.
    - `어떻게`게 할 것인가에 대해서는, 순수 "토끼"가 결정을 한다.



# 깨달은 점

OOP의 입장에서 모든 것들을 명시적인 Interface 로 노출시키는 것이 좋다는 것을 깨달았다.

단순, 덧셈, 뺄셈에 관련된 함수 또한 plus, minuse 의 이름으로 노출을 시키고 있다. 음수값으로 넘겨주면 됨에 불구하고 명시적으로 노출을 시킨다.

객체들은 자율성을 가지고 있으며, `의인화`를 통하여 세상과 다르게 표현을 시킨다.


# 면접에 나올만한 질문

## 위의 코드를, is-a / has-a 관계에 대해서 설명하시오

- Audience 는 Bag 을 소지하고 있는 개념으로 has-a에 해당이 됩니다.
- TicketSeller 의 역할은 TicketOffice 의 역할을 상속 받아 해결할 수 있으므로 is-a 관계로 구성을 바꿀 수도 있습니다.

### has-a 의 관계에 대해 더 설명하고 is-a 와의 어떠한 점이 다른지에 대해서 논하시오

has-a 관계는 포함 개념으로, 클래스가 다른 클래스를 멤버변수로 가지고 있게 됩니다.

이때 강한 coupling 이 생성이 되므로, 설계상의 문제를 야기시킬 수 있습니다.

is-a 관계는 상속 관계를 나타내므로, 단일책임의 원칙 및 의존성 주입 원칙에 따른 느슨한 coupling 의 구조를 가져갈 수 있다.


## 캡슐화에 대한 설명을 하시오

객체의 `속성`과 `행위`를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다.

### 캡슐화를 통해 얻는 이점을 무엇인가?

코드의 중복을 피할 수 있으며, 데이터를 처리하는 동작 방식을 외부에서 알 필요가 없다는 점.

