# 6장 메시지와 인터페이스

어떻게 하면 메시지와 인터페이스를 잘 설계할 수 있을까

### 용어정리

- 메시지
  - 객체가 다른 객체와 협력하기 위해 사용하는 메커니즘
- 오퍼레이션
  - 객체가 다른 객체에 제공하는 추상적인 서비스, 추상메시지?
- 메서드
  - 메시지에 응답하기 위해 실행되는 코드블록
- 퍼블릭 인터페이스
  - 객체가 외부에서 수신할 수 있는 메시지의 묶음
- 시그니처
  - 함수의 이름과 인자의 목록

---

## 인터페이스의 설계품질과 관련된 원칙

### 디미터의 법칙

- 객체의 내부 구조에 결합되지 말아라
  - 낯선 자에게 말하지 말라
  - 오로지 인접한 이웃하고만 말하라
  - 오로지 하나의 도트만 사용하라
   

- 아래 조건을 만족하는 인스턴스에만 메시지를 전송해야 한다
  - this 객체
  - 메서드의 매개변수
  - this의 속성
  - this의 속성인 컬렉션의 요소
  - 메서드 내에서 생성된 지역 객체

**[ 전형적인 디미터의 법칙 위배 ]**

- getter의 연쇄적 호출 (기차 충돌)
    ```
    screening.getMoive().getDiscountConditions();
    ```

### 묻지 말고 시켜라 (TDA : Tell, Don't Ask)

- 객체의 상태에 관해 묻지말고, 원하는 것을 시켜라
- 그렇게 해야 데이터와 행동을 함께 다루는 객체를 만들 수 있다

### 의도를 드러내는 인터페이스

- 인터페이스는 '어떻게' 하는지를 드러내지 말고, '무엇을' 하는지 드러내야 한다
- 어떻게 하는지 드러내는 메서드
  ```
  isSatisfiedByPeriod(Screening screening) { ... }
  isSatisfiedBySequence(Screening screening { ... }
  ```
- 무엇을 하는지 드러내는 메서드
  ```
  isSatisfiedBy(Screening screening) { ... }
  ```

- 이렇게 해야 메시지의 목적을 생각할 수 있고, 클라이언트의 의도에 부합하도록 이름을 지을 수 있다.

<br>

>의도를 표현하는 추상적인 인터페이스 뒤로 모든 까다로운 메커니즘을 캡슐화 해야 한다.


### 명령-쿼리 분리 원칙

- 오퍼레이션이 명령인 동시에 쿼리여서는 안된다
- 명령(프로시저)
  - 부수효과 O, 값 반환 X
- 쿼리(함수)
  - 부수효과 X, 값 반환 O

- 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기 어려워진다.
- 겉보기엔 쿼리처럼 보이지만 부수효과를 가지면, 잘못 사용하기 쉽다

<br>

객체지향 패러다임에서 상태를 변경하는 메서드는 부수효과를 가질 수 밖에 없다.

따라서 명령-쿼리 원칙으로 최대한 분리해서 사용해야 한다.

### 원칙의 함정

- 디미터의 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.
  - 예외) 자바 stream
  - 도트에 초점을 맞추지 말고, 내부구조에 결합되는지 안되는지 초점을 맞추자
- 객체에게 시키는것이 항상 가능한 것은 아니다.
  - 객체에게 무조건 시키려고만 하면 응집도를 떨어뜨릴 수 있다.
  - Screening이 할인 조건을 판단할 책임이 있는가?
  - 가끔은 물어야 한다





상태를 반환하는 것이 아니라 일시적으로 해당 연산에 대한 값만 반환하는것은 괜찮은가?
- 티켓 구매의 int buyTicket()